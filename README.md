# Some-Algorithm-implementation
Course Experiments on Algorithmic Design and Analysis
算法设计与分析课的一些实验作业，包括算法的实现以及一些扩展应用（java），具体内容见代码与实验报告

## 实验一  Fibonacci序列动态规划求解算法

两种思想：自上而下，自下而上

## 实验二  广度优先遍历算法


广度优先搜索是按层来处理顶点，距离开始点最近的那些顶点首先被访问，而最远的那些顶点则最后被访问

较常见的一种应用是用来解决迷宫问题上

## 实验三  深度优先遍历算法

图的深度优先搜索与树的先序遍历比较类似，是一个递归的过程。它的思想书要是假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。


## 实验四  最小生成树算法 

#### prim算法

每一步为一棵生长中的树添加一条边，总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入到树中

有延迟实现与即时实现两种

#### Kruskal算法

Prim算法一条边一条边地来构造最小生成树，每一步都为一棵树添加了一条边，Kruskal算法也是一条边一条边地来构造最小生成树，但是寻找的边会链接一片森林中的两棵树。主要思想是按照边的权重从小到大顺序处理他们，将最小的边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中有V-1条边为止。Kruskal算法能够计算任意加权连通图的最小生成树。


## 实验五  单源最短路径算法

#### 权重非负的加权有向图单源最短路径Dijkstra 算法

变种

1. 加权无向图时：对于给定的加权无向图，创建一幅有相同顶点构成的加权有向图，并对与无向图中的每条边，相应地创建两条有向边。再按照如上算法求解即可。
2. 给定起点s和终点t的最短路径：使用Dijkstra 算法并在优先队列中取到t之后终止搜索
3. 任意顶点对之间的最短路径：构造Dijkstra 对象的数组，每个元素都将作为相应的顶点作为起点。所需时间与空间都与EVlogV成正比

拓展

1. 无环加权有向图最短路径算法：按照拓扑顺序放松顶点，就能在和E+V成正比的时间内解决无环加权有向图的单点最短路径问题，并能够处理负权重的边。具体实现
2. 无环加权有向图单点最长路径算法：同最短路径算法，只不过将初始距离的初始值设置为负无穷小且放松方法中的不等式方向改变即可

#### Bellman-Ford

可能含有环也可能还有负权重的边的加权有向图中的最短路径算法

## 实验六  Floyd-Warshall算法

Floyd-Warshall算法是解决任意两点间的最短路径的一种算法。通常可以在任何图中使用，包括有向图、带负权边的图。同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。


## 实验七  最大流问题

Ford-Fulkerson算法是一种贪婪算法，用于计算流网络中的最大流量.
对增广路径的寻找方法的不同形成了求最大流的不同算法，这也是Ford-Fulkerson被称之为“方法”而不是“算法”的原因。

Edmonds-Karp算法.
基于BFS的算法通常称为Edmonds-Karp算法，该算法是“最短”扩充路径，这里的“最短”由路径上的边的数量来度量，而不是流量或者容量。
## 实验八  并查集

并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。

#### quick-find算法

在同一连通分量中的所有点在id[]中的值相同。

find()操作只需将id[]的值返回即可

union()操作需要遍历一次数组

#### quick-union算法

每一个点对应的id[]元素都为同一连通分量中其他元素或自己。

find()操作我们需要从某一点开始，由连接找到另一个点，直到找到根节点为止

union()操作我们需要找到两个点的根节点，并将其中一个根节点设置为另一个的根节点

#### 加权quick-union算法
对quick-union算法的改进，记录每一棵树的大小并总是将较小的树连接到较大的树上，增加size[]数组记录树的大小。处理N个节点和M条连接时最多访问数组cMlgN次，其中c为常数

find()操作与quick-union算法完全相同：从某一点开始，由连接找到另一个点，直到找到根节点为止

union()操作在quick-union算法的基础上，同时维护size[]数组，确保总是将较小的树连接到较大的树上，并更新较大树的size[]元素。

#### 路径压缩的加权quick-union算法

在检查节点的同时将他们直接连接到根节点，通过这样，可以得到近乎扁平化的树

find()操作在加权quick-union算法基础上，添加一个循环，将路径上遇到的所有节点直接连接到根节点


